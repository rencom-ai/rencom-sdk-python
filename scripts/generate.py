#!/usr/bin/env python3
"""Generate SDK code from OpenAPI specification.

This script:
1. Downloads the latest OpenAPI spec from the Rencom API
2. Generates Python code (models, API clients, types)
3. Places generated code in rencom/_generated/
4. Reports any breaking changes

Usage:
    python scripts/generate.py [--spec-url URL] [--output-dir DIR]

Environment variables:
    RENCOM_API_URL: Base URL for the API (default: https://api.rencom.ai)
"""

import argparse
import json
import subprocess
import sys
import urllib.request
from pathlib import Path
from typing import Any


def download_openapi_spec(api_url: str) -> dict[str, Any]:
    """Download OpenAPI specification from the API.

    Args:
        api_url: Base URL of the API

    Returns:
        OpenAPI spec as dict

    Raises:
        Exception: If download fails
    """
    spec_url = f"{api_url}/openapi.json"
    try:
        with urllib.request.urlopen(spec_url, timeout=30) as response:
            spec = json.loads(response.read())

        # Validate it's a valid OpenAPI spec
        if "openapi" not in spec:
            raise ValueError("Invalid OpenAPI spec: missing 'openapi' field")
        if "info" not in spec:
            raise ValueError("Invalid OpenAPI spec: missing 'info' field")

        return spec
    except Exception as e:
        raise Exception(f"Failed to download OpenAPI spec from {spec_url}: {e}") from e


def generate_models(spec: dict[str, Any], output_dir: Path) -> None:
    """Generate Pydantic models from OpenAPI schemas.

    Args:
        spec: OpenAPI specification
        output_dir: Directory to write models.py to
    """
    output_dir.mkdir(parents=True, exist_ok=True)

    # Save spec to temp file
    temp_spec = output_dir / "openapi.json"
    with open(temp_spec, "w") as f:
        json.dump(spec, f, indent=2)

    # Generate models using datamodel-code-generator
    models_file = output_dir / "models.py"
    try:
        # Use sys.executable to ensure we use the same Python environment
        subprocess.run(
            [
                sys.executable,
                "-m",
                "datamodel_code_generator",
                "--input",
                str(temp_spec),
                "--output",
                str(models_file),
                "--output-model-type",
                "pydantic_v2.BaseModel",
                "--use-annotated",
                "--use-standard-collections",
                "--field-constraints",
                "--snake-case-field",
            ],
            check=True,
            capture_output=True,
            text=True,
        )
    except subprocess.CalledProcessError as e:
        raise Exception(f"Model generation failed: {e.stderr}") from e
    finally:
        # Clean up temp file
        temp_spec.unlink(missing_ok=True)

    # Add header warning
    header = '''"""AUTO-GENERATED CODE - DO NOT EDIT.

This file is automatically generated from the OpenAPI specification.
Any manual changes will be overwritten on the next generation.

Generated by: scripts/generate.py
"""

'''
    content = models_file.read_text()
    models_file.write_text(header + content)

    # Create __init__.py for the _generated package
    init_file = output_dir / "__init__.py"
    init_file.write_text(
        '"""Auto-generated models and types."""\n\nfrom rencom._generated.models import *  # noqa: F401, F403\n'
    )


def generate_api_clients(spec: dict[str, Any], output_dir: Path) -> None:
    """Generate low-level API client methods.

    Args:
        spec: OpenAPI specification
        output_dir: Directory to write API clients to
    """
    # We generate clients manually for better DX
    # This function is intentionally not implemented as per architecture decision
    pass


def generate_types(spec: dict[str, Any], output_dir: Path) -> None:
    """Generate type aliases and enums.

    Args:
        spec: OpenAPI specification
        output_dir: Directory to write types.py to
    """
    # Types are included in generated models
    # This function is intentionally not implemented as per architecture decision
    pass


def detect_breaking_changes(old_spec: dict[str, Any], new_spec: dict[str, Any]) -> list[str]:
    """Detect breaking changes between OpenAPI specs.

    Args:
        old_spec: Previous OpenAPI spec
        new_spec: New OpenAPI spec

    Returns:
        List of breaking change descriptions
    """
    changes = []

    # Check for removed endpoints
    old_paths = set(old_spec.get("paths", {}).keys())
    new_paths = set(new_spec.get("paths", {}).keys())
    removed_paths = old_paths - new_paths
    if removed_paths:
        for path in removed_paths:
            changes.append(f"Endpoint removed: {path}")

    # Check for removed schemas
    old_schemas = set(old_spec.get("components", {}).get("schemas", {}).keys())
    new_schemas = set(new_spec.get("components", {}).get("schemas", {}).keys())
    removed_schemas = old_schemas - new_schemas
    if removed_schemas:
        for schema in removed_schemas:
            changes.append(f"Schema removed: {schema}")

    # Check for version changes
    old_version = old_spec.get("info", {}).get("version")
    new_version = new_spec.get("info", {}).get("version")
    if old_version != new_version:
        changes.append(f"API version changed: {old_version} → {new_version}")

    return changes


def main() -> int:
    """Main entry point for code generation."""
    parser = argparse.ArgumentParser(description="Generate SDK code from OpenAPI specification")
    parser.add_argument(
        "--spec-url",
        default="http://localhost:8080",
        help="Base URL to download OpenAPI spec from (default: http://localhost:8080)",
    )
    parser.add_argument(
        "--output-dir",
        type=Path,
        default=Path(__file__).parent.parent / "rencom" / "_generated",
        help="Output directory for generated code",
    )
    parser.add_argument(
        "--check-breaking",
        action="store_true",
        help="Check for breaking changes compared to openapi.json",
    )
    args = parser.parse_args()

    try:
        print(f"Downloading OpenAPI spec from {args.spec_url}...")
        spec = download_openapi_spec(args.spec_url)
        print(f"✓ Downloaded spec version {spec['info']['version']}")

        # Check for breaking changes
        if args.check_breaking:
            old_spec_path = Path("openapi.json")
            if old_spec_path.exists():
                print("Checking for breaking changes...")
                with open(old_spec_path) as f:
                    old_spec = json.load(f)
                breaking_changes = detect_breaking_changes(old_spec, spec)
                if breaking_changes:
                    print("⚠️  Breaking changes detected:")
                    for change in breaking_changes:
                        print(f"  - {change}")
                else:
                    print("✓ No breaking changes detected")

        print("Generating models...")
        generate_models(spec, args.output_dir)
        print(f"✓ Models generated in {args.output_dir / 'models.py'}")

        print("Generating API clients...")
        generate_api_clients(spec, args.output_dir)

        print("Generating types...")
        generate_types(spec, args.output_dir)

        # Save spec for future comparison
        print("Saving OpenAPI spec to openapi.json...")
        with open("openapi.json", "w") as f:
            json.dump(spec, f, indent=2)
        print("✓ Spec saved to openapi.json")

        print("\n✅ Code generation complete!")
        print(f"   Generated code written to {args.output_dir}")
        print("   Run 'pytest' to verify everything works")

        return 0

    except Exception as e:
        print(f"\n❌ Error: {e}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    sys.exit(main())
